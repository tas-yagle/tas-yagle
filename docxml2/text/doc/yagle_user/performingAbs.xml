<?xml version="1.0" encoding="ISO-8859-1" ?>
<chapter>
<section niv='1'><title>Performing the Abstraction</title>

&file_loading;

<section niv='2'><title>General Configuration</title>

&power_supplies;

</section>

<section niv='2'><title>Invoking Functional Abstraction</title>
<p>The functional abstraction routine is invoked by the
<f>yagle</f> command, which takes as argument the name of a sub-circuit. The sub-circuit must be among 
the previously loaded netlists. If the sub-circuit contains instances it
will be flattened to the transistor-level.  In such a case, signal naming 
respects the hierarchical paths. The name of a signal is the concatenation of 
the names of the successive instances that appear in the hierarchical path leading to the physical node the signal
is associated with. 

The typical Tcl command for invoking functional abstraction is:</p>
<code>yagle my_design</code>
<p>where <f>my_design</f> is the name of the <f>.SUBCKT</f> to treat. If flatten is impossible (i.e. transistor level sub-circuits
are missing for leaf cells), with no further configuration, the tool will issue an error and exit.</p>
<p>The default configuration creates a VHDL description.</p> 
</section>

<section niv='2'><title>Timing Back-Annotation</title>
<section niv='3'><title>Defining Simulation Temperature</title>
<p>Temperature can be deined either with the <f>simTemperature</f> configuration variable or through 
a <f>.TEMP</f> statement in the Spice file.</p>
</section>
<section niv='3'><title>Back-Annotation Level</title>
<p>The level of accuracy used for the back-annotation is <f>yagleTasTiming</f></p> 
</section>
</section>

<section niv='2'><title>Output Files</title>
<section niv='3'><title>CNS, CNV files</title>
<p>The <f>.cns</f> file describes the partitions (cones), and their interconnections, resulting from the disassembly process.
This file is very useful for debugging purposes, and necessary for the spice deck generation of timing paths. The
file can be generated with the following configuration:</p>
<code>
<cl>avt_config yagleGenerateConeFile yes</cl>
</code>
<p>The <f>.cns</f> file is intented to be re-read by &tool; and therefore is not very human-readable. A more friendly
version can be generated by setting:</p>
<code>
<cl>avt_config avtVerboseConeFile yes</cl>
</code>
</section>

<section niv='3'><title>VHDL and Verilog files</title>
<p>VHDL file is generated in default mode. a Verilog file can be generated instead by using the following 
configuration:</p>
<code>
<cl>avt_config avtOutputBehaviorFormat vlg</cl>
</code>

</section>


</section>

<section niv='2'><title>Special Elements</title>
<section niv='3'><title>Transmission Gate Multiplexers</title>
<p>The detection of multiplexors is done purely algorithmically. The cone partitioning strategy implemented in &tool; perfectly
fits with the detection and modeling of transmission-gate based multiplexers, provided that the correlations
between the commands can be resolved within the design. The only reason why detection may fail, is because the
schematic of the design itself prevents to identify those correlations, for example when commands are input pins.
In such a case, correlations (mutual exclusion) should be set externally with INF commands.</p>
<p>The following diagram shows two situations. In the left-hand design, the mutual exclusion between <f>sel</f> and <f>nsel</f>
is not ensured by the design. There is no way for the tool to identify inputs and outputs, and it constructs
false current paths. In the right-hand design, the mutual exclusion between
<f>sel</f> and <f>nsel</f> is ensured by the invertor, and therefore the tool correctly models the multiplexer. </p>
<imgsize xmlns="http://www.w3.org/2000/svg" namehtml="mux.gif" namepdf="mux.svg"/>
<p>To avoid the construction of false current paths in the left-hand design, the following mutual exclusion
configuration should be set:</p>
<code>
<cl>inf_DefineMutex cmpUP {sel nsel}</cl>
</code>
<p>If the transmission gate toppology is more complex, and setting of mutual exclusion constraints
become too much difficult, another orientation mechanism is available. Let's consider the next design:</p>
<imgsize xmlns="http://www.w3.org/2000/svg" namehtml="mux2.gif" namepdf="mux2.svg"/>
<p>Here orientation can be done by setting levels on signals <f>i0</f>, <f>i1</f>, <f>s</f> and <f>out</f>.
The transistors are oriented by assuming the current is going from the signals with the higher level to
the signals with the lower level. Levels should be set as follow:</p>
<code>
<cl>inf_DefineDirout i0  3</cl>
<cl>inf_DefineDirout i1  3</cl>
<cl>inf_DefineDirout s   2</cl>
<cl>inf_DefineDirout out 1</cl>
</code>

<p>The default orientation value of signals is <f>-1</f>.</p>

</section>

<section niv='3'><title>Latches</title>
<p>Two algorithms exist in &tool; to detect latches. The first one is based on pattern-matching. The tool tries to
match in the design built-in latch patterns. This algorithm is enabled with the <f>yagleStandardLatchDetection</f>
(default behavior is enabled). The second algorithm is based upon the Boolean analysis of gate loops and an electrical
analysis of conflicts. This algorithm is enabled with the <f>yagleAutomaticLatchDetection</f> variable (default behavior
is not enabled). The two algorithms can be enabled together, in such a case the standard latch detection is performed
before the automatic latch detection.</p>
</section>

<section niv='3'><title>Dynamic Latches</title>
<p>Dynamic latches are typically tristate nodes followed by a capacitance. In default mode,
tristate nodes are not marked as latches. This behavior can be changed with the <f>yagleMarkTristateMemory</f>
configuration variable.</p>
<p>Dynamic latches can also be identified with the INF commands <f>inf_DefineDLatch</f> and <f>inf_DefineNotDLatch</f></p>

</section>

</section>
<section niv='2'><title>Case Analysis</title>
<p>Case analysis, such as Scan Mode analysis or Functional mode analysis, is available in the &tool; platform. It
is performed by sticking input connectors or internal signals to logical low or logical high values. It is done by adding in the Tcl
script the SDC command <f>set_case_analysis</f>.</p>
<p>The logical value stuck on the input connector or logical signal is propagated through the design, with regard
to the behavior of the gates it crosses. A report of the stuck signals is available in the <f>.rep</f> file:</p>
<code>
<cl>[WRN 30] Signal 'ram_na3' is stuck at Zero</cl>
<cl>[WRN 31] Signal 'ram_a43r_net6' is stuck at One</cl>
</code>

</section>
</section>
</chapter>


